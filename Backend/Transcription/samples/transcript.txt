 The topic for this video is heap. Under this topic we are going to learn about these things. I will be explaining these things that is array representation of bioretree's complete binary heap. How to insert and delete in heap, then heap sort. There is one of the important topic and heapify. This is one of the famous algorithm or a procedure for creating a heap. I will discuss this one. Then heaps are famous for being used as a priority queue. So we will learn about priority queues. So these are the subtopics under this heap topic. If you know all these things then you can understand heap sort. You can also understand heapify and priority queue unless you know these things. So directly jumping on the set certificate to understand that. So that is the reason I am covering all these things. So if you know all the few things you can skip and go to that topic any particular topic. Now before I start I have to say something. See I have two courses in Udemy. One is for C++ second one is for data structures. Both the courses are for beginner level as well as advanced level. Means if you already know data structure and C++ you have lot of things to learn there. And also if you are a beginner if you have never done any programming then you can take up C++ course and start learning programming. And both the courses are suitable for academics as well as for interviews. So C++ programming one course is there that is for beginners to advance level. You can learn up to the level of interview you can crack any interview. Then data structure course using C and C++ and some algorithms are it is not complete algorithm it is just a data structure using C and C++ right and few algorithms are there. So that subject is for academics as well as for cracking job interviews or coding interviews right. So I have covered all the topics in greater details so that will definitely improve your skills. So you can buy those two courses those are paid courses those are not free and don't please don't ask for free copants. The link for those courses is given in the description you can check the description and there is a discount code is there discount coupon code is there that is around 10 or 11 dollar. So you can click and go to Udemy and if more discounts are applicable Udemy will give you that discount. Don't worry about that if still it can be reduced it will reduce it. So I suggest you take this course and by clicking on this link you go there. So let us start with the topic. First I will discuss about representation of a binary tree using array. So here I have some examples. This is a binary tree. I have taken the alphabets here so that is easy to read. This is a binary tree and if I have to store it in an array this is an array already have taken in the CC++ programming array starts from index 0 but here I have taken from one onwards. So this is just a theoretical on paper when you want to program write a program then you can start from index 0 also but usually this is studied by taking index 1 onwards. So I have taken index 1 then these elements are stored here. So how they are stored? See for storing a binary tree we have to take care of two things. One is we have to store all the elements. Second is the relationship between them who is a parent who is a child who is left child who is right child. So these are the things that we have to take care. So elements and the relationship between the elements. So how they are preserved watch here. See the elements are stored here. A, B, C, D, E, F, G. So actually they are filled level by level A, B, C, D, E, F, G, S. They are filled level by level. Then where is the relationship? The relationship between them is formed by these formulas. So what are these? Let us look at. See if any node is at index i then it's left child is at index 2 into i. Right child is 2i plus 1 and its parent will be i by 2 floor value. So let us look into this example and observe really these formulas are used here or not. Let us check. B, B is at index 2. Who is a left child of B? D. So where it should be? 2 into i. So 2 into 4. Yes, it is at 4. Then E is right child. Where it should be? 2 into i plus 1. 2 into 2 plus 1. That is 5. So check on 5. Yes. Then C, C is at index 3. Then it's left child F. So 2, 3, 6. So it should be 6. Yes. Then G is the right child. It should be 2 into i plus 1. 2 into 3 plus 1. 7. Yes, it is at 7. So yes, these are followed. Now one more thing. S. Who is a parent of F? This is 6. 6 by 2. It's a 3. Go to 3. Yes. C is the parent. So you check here in the tree. Then for 7, this one G. Who is a parent? See, 7, 7 by 2. 7 by 2 is 3.5. But we have to take floor of all the elements. Just 3. So go to index 3. Yes, C is there. So this gives the parent. So now we learn that actually these elements are stored by following the formula. Now every time you do not use the formula and put them. So instead of using the formula, one thing we do is we fill them level by level A, B, C, D, E, F, G. So that's it. So these formulas are automatically followed. Now let us look at another example. Here I do not have these nodes. No problem. Fill them level by level A, B, C, D, E. Three ends here. So A, B, C, D, E. So if you apply those formulas, you check by yourself, they are followed. Right? Left child, right child and parent formulas are followed automatically. Now let us look at this one. A, B, C, then D, no. When I am filling level by level without using the formula and I want the formulas to be followed automatically, then I should fill level by level. And if any element is missing, I should leave a gap there. Yes, this is the important point. Now actually, B should have its left child, which is not there. Right child, which is not there. So put a blank there. Yes. A, B, C, blank, blank, D, E, A, B, C, blank, blank, D, E. This is how they are fed. Now if you see D, who is a parent of D? Six by two. This one. Six by two. Three. Yes. Three, who is there at a three? C is there. If I do not write D there, if I write here, then it becomes a left child of B. That will be wrong. So it means left child is not there for B. So this place must be blank and D should be filled here. So without following formulas, if you want to fill them, then make sure that if there are missing nodes, you leave a blank there. So that's all about a representation of binary tree that is done using these formulas. These formulas are for maintaining relationship and the elements are as it is stored in an array. Now next we will understand what is complete binary tree. Now let us learn what is full binary tree and what is complete binary tree. So first full binary. See this binary tree, this we have already seen it. So this is a full binary tree. What does it mean by full? See the height of a binary tree, this is 012. So the height is 012, height of a binary tree is true and in that height it is having maximum number of nodes. If you want to add any node, then the height will increase and if you remove any node, then this is missing. It's not having all possible node. One more node is possible. So you can take this. So now this is having full in height 2. Now this is in height 3, this is full binary. There is no space for any new node. So that tree is called as a full binary tree and if the height of a binary tree is h, then a full binary can have 2 power h plus 1 minus 1 number of nodes, maximum these many nodes. So a binary tree with maximum number of nodes is a full binary. Now what is complete binary? Let us learn this now. See look at this one. When I have represented this in an array, then from last first element to the last element, there is no missing element. So this is complete. If you look at this, if you check the first and the last element, there is no missing element. It's a complete binary tree. Here from the first element to the last element, if you check in an array, there are some missing elements. So even if there is a single missing element, it is not a complete binary tree. This is not a complete binary. So the definition is, my definition is if you represent a binary tree in an array, then they should not be any empty locations or gaps in between the elements. Bills from first element to last element in between anywhere. After the last element spaces there, then there is no problem. Suppose this array is having only 5 elements. If I have one more six like a location, that is not a problem. But in between the elements, that is the important thing. Now if you look at this, now you tell me whether it is complete or not. Yes, it is full as well as complete. So every full binary tree is also complete binary tree. Now check this. Is it complete or not? Check level by level. One node is there, two nodes are there, one, two, three, four nodes are there. Then this next next next. Yes, it is complete binary. If I remove this node, then it's not a complete binary. This is missing. This is missing. So no node must be missing. If I remove this, then this is not a complete binary. So this is missing. So if you go level by level, they should not be any missing. One, then in this level two nodes, this level four nodes. Yes, all are there. Last level, all nodes are not there. All nodes are not there. No problem. If all nodes are there, then it's a full binary. So one more definition of complete binary. This mostly you find in the textbooks. See, of complete binary tree is a full binary tree up to height h minus 1. If you height this and see, it's a full binary. And in the last level, the elements are filled from left to right. This is one of the definition you'll find in the textbooks. A complete binary of height h, height h is already a full binary up to height h minus 1. Last level, the elements are filled from left to right. That same thing, I am saying that if you represent this in an array, you will not get gaps like this. If you are getting gaps, it's not a complete binary. Without gaps, it's a complete binary. Now one more important thing. See, the definition of complete binary, what I gave you. Sometimes or some authors, some people call this as almost complete binary also. But in most of the textbooks, you'll find this as complete binary. So I am calling it as complete binary. Now I draw few trees and show you which one is complete, which one is not complete, so that you get comfortable with complete binary trees. So I'll remove this and I will show few binatries. Look at this. Is it a complete binary? Check level, well, well. First level one node, then two nodes, then four nodes. All four are not there. If you start from left side, then one two. No node is missing. So it's a complete binary tree. That this one. Road is one. The next level two nodes. Next level four are there. All four are not there. But left hand side, the extreme left side is there. So yes, it's a complete binary. Road is one. Then two, this level two. Then next level, all nodes are not there. But first which node must be there? Actually, it should have this node, then this node, then this is allowed. So these two are missing. So it's not a complete binary. Now this one. First level one, the next two nodes. Okay. Next level all nodes are not there. But first of all, we should have this node, then this node, then this node, then we can have this. So we should have the nodes from left to right. But the three nodes are missing there. It's not a complete binary. So if you represent this in an array, let us say this is one, two, three, and this is four. Then one, two, three, gap, gap, and a gap. And then four. So you'll get the three blank spaces in between the elements. So it's not a complete binary. What about this? Let us check. First level one. Next level two nodes. Next level four nodes must be there. One, two, three, four. These are missing. So it's not a complete binary. What about this? This is there. Right? Two nodes. Then four must be there. One, two. This is missing. So it's not a complete binary. This one. One, then here two nodes. Then here one, two, three, four nodes. Okay. Then last level all nodes are not there. But we have this extreme left. Yes. This is the end point. After this nodes are not there, that is not a problem. This is a complete binary. Now you are comfortable with what is complete binary. And one last point of a complete binary is that the height of a complete binary will be minimum only that is log n. Height of a complete binary will always be log n because unnecessary, we are not going to the next level unless one of the level is filled unless this is filled, we will not go to the next level. See unless this is filled, we will not go to this level. It's not a complete binary if you are going to the next level. So always the height of a complete binary will be minimum that is log n. This is the interesting fact of a complete binary. Now next we will learn about heave. Let us learn heave. See for that I have example binaritries here. This binary tree is a full as well as it's a complete binary tree. Yes. The important thing is complete binary. This is also complete. This is also complete. Now first of all heave is a complete binary tree. Then next condition. See the condition. Let us look at the elements 50. Then 30 and 20 are smaller than 50. Yes. 15 and 10 are smaller than 30 and 8 are and 16 are smaller than 20. So it means every parent is having the value greater than all its descendants. Every node is having the value greater than all its descendants. So a root will have the largest value that is maximum value. So yes if the elements are arranged like this then it is called as max heave. So I repeat max heave is a complete binary satisfying the condition that every node is having the element greater than all its descendants. Greater than or equal to also all its descendants. So duplicates are allowed here. So if you have duplicates you can have them in descendants coming into this one. Here this is 10. 30 and 20 are the children that are greater and this 35 and 40 are greater than 30 and also 10. So 32 and 25 are greater than 20 and also in turn they are greater than 10 also. So here the smallest element is there in the root. So every node is having the element smaller than all its descendants or smaller than or equal to all its descendants. So this is called as mini heave. So again I repeat mini heave is a complete binary satisfying the condition that every node is having the element smaller than or equal to all its descendants. So there are two types of heave, max heave and mini heave. So whatever we have to study will study upon one heave and same thing applies on the next heave also. So we will take max heave and study this one. So we will learn how to insert and delete the element. So first let us look at insert operation in a max heave. I will show you insert operation in max heave. Let us understand how insertion is written. So already I have a max heave here. This is a diagrammatic representation of a heave that is complete binary and that is this is the ordinary presentation of same thing. This is stored in an array. If you check root 50 then this is 30 20 30 20 15 10 8 16 15 10 8 16 there are no gaps in between the elements in between these two. There are no gaps. So it is a complete matrix. It is perfect. Let us insert. I want to insert element 60. So let us insert 60. So I want to insert this 60 in this max heave. So let us see. See where this 60 should come. Root should have the largest element. So 60 should come in root. Yes. Now what usually people think I will talk about that. Then I will show you what is the right method. People think that 60 should be inserted here. Then where 50 should go. 50 should go. Okay. This is 30 that is 20. So this is small enough. 50 should go this side. Okay. Then where this 20 should go. 20 should come in this side. So in this way it will extend in this direction. 16 will come here and this will become 20 and this will become 50 and this will become 60. Now if we do it like this is it a complete binary? No. All these are missing element. Then we have the 16 here. This is wrong. So don't insert it in the root. So I have shown you the wrong procedure or wrong assumption what people will have. This is wrong. It is not inserted in the root. Then how it is inserted. Where it is inserted? Look at this. The correct procedure. See we actually implement in an array. So that 60 should be inserted here at the last free space in an array. Our heap was ending here. Right. It was ending here. Now I have 16 included there at that free space. Right. So in diagram where it will be. 60 will be on the left child of 15. Check it. Where is 15 at 4? 248. Yes it is a left child of 15. So this 60 is inserted here. Inserted here. Yes. It is not a part of heap. I have kept it separately. Now is it forming a heap? No. That condition is violated. Every node should have the value greater than all its descendents. But you see 60 is there. That is the child of 15 wrong. Then what to do? Adjust the element. Adjust the element. Make it as a heap or insert it in a heap. How? Compare with the parent. Who is a parent? 60 is greater than 15. So 60 should go up. And again compare with the parent. 60 is greater than 30 also. So it should go up. And 16 is greater than 50 also. So it should go up. So check here in this diary in this array representation. 8 8 by 2 4. So check with this one. 4 by 2. 2. Check with this one. 2 by 2. 1. Check with this one. So 60 is compared with this one and its parent and its parent. So 60 is compared with all its ancestors and it will reach it's right place. So it will swap all these elements and 60 will go there. So I will draw it here. See 60 will come here. I will draw it right first. Then I will fill the elements. Right? After inserting how it looks like. Now this is a array. So here I kept them empty. Just watch it. 60 will go up. 15 will come down. And again 60 will go up and 30 will come down. 30 will come here. Then 60 will go up and 50 will come down. So we adjust the element like this. So 60 comes here. So it has moved up in the hierarchy towards the ancestors and it has reached the root because now it is the largest element. So in an array if you see 60 was here. So 15 went 60 was here. So this 15 went there and 60 came here. Then again 30 went there and 60 came here. Then 50 went to its place and 60 is inserted here. So this is how the heap looks like diagrammatically and also in an array. So this is insertion. We have inserted only one element in a heap. That too we have to take a max heap. Now a little bit analysis. How much time it has taken? It has taken the time equal to the number of swaps. So maximum how many swaps? 1, 2, 3. So actually this is depends on height of a tree. So what is the height of a complete binary tree? Height of a complete binary is log n. Yes. So it means the time is big of log n or order of log n. So the time taken for insertion is log n. How many swaps are required? 1, 2, 3. So that depends on the height. Log n number of swaps are required. And one more thing. If suppose this was not 60. If this was 6 then we do not have to swap anything. Zero swaps. So we can say that the time taken for inserting one element in a heap is minimum big of 1 and maximum is log n. It can be from one constant to log n. Minimum time is no swapping is required. Maximum the swapping requires depends on the height. So that is log n. So this was inserting just one element in existing heap. Now before going to delete I have something to show you observe one thing. See when we are inserting we have to send the element upwards. First we add the new element as a leaf. Then we adjust it by comparing with the ancestors. So element moves from leaf towards root. So the direction of adjustment is upwards. This is the important thing. This is the important thing. So anyway next I will take the same example then in this one only I will show you how to delete. So let us look at. Now let us look at delete operation on max heap. Here is a max heap with 7 elements that are also there in a array. Now which element you want to delete? See the first and important thing you cannot delete any other element. You should not delete any other element but root element. So only one element is deleted from the heap without asking or without giving any options or choices. Only root element is deleted. Yes if you are deleting root element then only it is a heap. See this heap is just like if you have seen in the market at a fruit shop if apples are arranged how they arrange they arrange it like pyramid heap like. So the apples are arranged one above another like forming a pyramid like shape. So on the top which apple is kept? The best apple the most shiny one among all fresh one is kept on the top. So that is the best one. So same concept is used in heap also. So all these elements are there which is the top most element best element what is best for us? Maxing a so that is max heap. So 50 is on the top. So if you want to remove the apple which apple you will remove you cannot remove any other apple from that heap you have to remove the top most apple only that is what. So we follow the same method here we will remove only the root element. Similarly in min heap also if you say no maximum element is not important for us minimum is important then that you follow min heap. Okay coming to this let us delete the element. So only I can delete 50. 50 is gone. Now again sometime people mistake here the thing that 30 should go up because this is bigger. Okay 30 will go up then who will come at the place of 30? 15. So 15 goes here 30 goes here then this node is gone. If this node is gone is it working like a complete binary? No. So if you try to adjust as you like it will not be a complete binary. So you have to be careful for preserving complete binary property then what to do? So when 50 is gone who should take its place? See the last element in complete binary this element this element will come in its place that is 16 will come here. So 16 is removed from here. So 16 is brought here 16 is removed from here. This is gone. So 16 is brought there 50 is gone outside we have deleted that 50. 50 has gone out we have deleted it. Then in its place the last element in complete binary last element in complete by and remains in another the last element will take its place. Now this is how it looks like. So I will remove this one now. Okay I will remove this this is gone. So you have already seen it it's here now. Now this is complete by and yet we but not a max heap. So we have to adjust the elements. Okay we will adjust the element that is not a big deal maintaining complete binary property is very important. So we preserve that. Now adjusting the element. So we will adjust how from the root towards leaf we will send it. So let us check how to do this. Compared children of this 16 that is new root which child is greater. 30 is greater. So 30 will take its place 16 will come into its place. So I will draw it here. So here 30 goes here 20 and 8 remain 16 comes here and 15 and 10 as it is. So I will fill them in this array also. 30 is here 10 and 20 and this is 15 and 10 and 8. This place is free. Last place is free. So how we have done it is see this 16 was compared with its children. Who are children of 16, 2 and 3 left child and right child left child and right child. 1 into 2 1 into 2 plus 1. So 2 into 1 and 2 into 1 plus 1. So if you remember this formula 2 i 2 i plus 1. So this is 2 and this is 3 2 and 3. These are 30 and 30 are the children we compared and 30 is brought here 16. So now this is one step we have completed. Still we have to check with the descendants. So let us check with the descendants 16 who are the children of 16 15 and 10 compare them which is greater 15. Now is this 15 greater than 16? No. First of all compare the children and whichever child is greater that you compare with the parent. Okay. After words you compare it. Now but 16 is greater than both of them. So leave it. It's already there in max heap. So this is in max heap you don't have to swap them. So this is a delayed procedure. So I will just repeat this steps quickly. See always in delayed we remove root and the last element in complete biointerval will take the place and we push the element downwards towards leave and adjust the elements to form a max heap. So we have adjusted downwards. So from root towards leave. If you remember in insert the adjustment was done from leave towards root but now the adjustment is done from root towards leave. So in division adjustment is done but the direction is different. So in both insert and delayed adjustment is done but the directions are different. Now little bit of analysis. How much time it has taken for deleting one element? It depends on the height. So what is the maximum adjustment you have to do? That depends on the height. So the maximum time is login. Login. Yes. So deletion takes log in time. Now one important thing we understood here is that from the max heap whenever you delete you get the largest element from the heap. 50 was largest 50 was gone but now who is largest? Next largest element is 30. If you delete which will be deleted? 30. Then from the remaining 20 who will come and sit in the room? 20 will come and sit in the room. So if you delete next 20 will be deleted. Yes. So from max heap whenever you delete you get the next largest element. From mean he whenever you delete you get the next minimum element. So you get the smallest then next smallest then next smallest and so on. Now last important thing this is very important. Listen carefully. See this is important. Here the array size was 7. One element is deleted. Now what is the heap size? 6. heap is still 6 only from 1 to 6. 7th place in an array is free that is not a part of heap. Yes. Leave it no problem. Our heap is still 6 only. That space is vacant after that. So it's not a problem for us but what element we deleted? 50. Where it is? We are using it. But if you want to maintain that copy of 50 there is a free space here. You keep 50 here. This is interesting. I kept 50 there. Is it a part of heap? No. It's outside heap. Yes. So it's not a part of it. Just a space was free so I kept it there. That's all. Away from heap. Right. Now from this 6 elements if I delete again what will be deleted? 30 will be deleted and 8 will come here. Then we adjust. So 20 comes here and 8 goes here. Then 8 with it's a child that is 10. So 10 comes here. 8 goes there. So now the heap reduces to this. So the heap size is 5. Which element I deleted? Just not 30. These two places are free. Already I kept 50 there. Now 30. Keep it here. Next free place. If I do this what happens? Next element will be 20. Next element will be 10 and so on. See this is 16 I think. So it will be so on. So what happens? You we are getting the elements largest. The next largest. The next largest. The next largest. So if you read the elements from this side they are sorted. They are sorted. Yes. This is the idea of heap sort. If you have a heap then delete the element and fill it in the empty place obtained after deletion. So if you go on filling the elements there then automatically gets sorted. So from the heap go on deleting the elements and start filling them in free spaces. So this is heap sort. So let us take few elements and see the complete heap sort. Now heap sort. Heaps sort have two steps. First is for a given set of elements create a heap by inserting all the elements one by one. Then once the heap is formed delete all the elements from the heap one by one. The elements will get sorted. So I repeat the procedure of heap sort have two steps for the given set of number first of all create a heap then delete all the elements from the heap. First step create a heap second and step delete all the elements from a heap. So I already have some set of elements here in an array these are the elements we have to sort them. So I will first show you how to create a heap. How the heap will be created inside the array I am also going to show you diagrammatically. So let us start. Suppose these are the set of elements that we have to sort they are not sorted. So first of all create a heap. So for that initial array these elements are initial array. So we assume that in this first element is already in a heap. So this is 10. So right now there is only one element and a heap. So when you have only one element you can call it as max heap also when he calls so it's a heap. Definitely it's a heap. Now we will insert second element. So second element we will insert that is 10 is already in the heap. Now we will be inserting 20. So 10 is already there. So 20 we will insert. So 10 here 20 here. So rest of the elements I am not writing them. Okay I will be writing one I will be writing one by one. Now inserting 20. How do insert already have shown you compared with the ancestor that is parent and its parent and so on and try to address the element. Check 20 with 10. Right so this is greater. So 20 should go up and 10 should come down. 20 should go up and 10 should come down. So here in an array 2 is the index of 20. 2 by 2 is 1 compared with the parent 1. So yes 20 will come here. 10 will go there. Right now this is heap. So we have a heap of two elements. There's a heap of two elements. Now third element we will include. So right now we have 20 and 10. Now the new element is the next free space. So next free space is this one. Yes. So the element is 15. So we are going to insert 15 now. This one earlier we have inserted the element from here. Right. Now 15 we are inserting. So right now we have 20 and 10 here. So 15 is inserted here. Now try to adjust it. How? Compare with the parent. So who is the parent of 15? 3 by 2 s 1. So compared with the parent 15 is smaller. So all the day it is in the max heap form. We don't have to adjust. So till here we got a heap. Now insert the next element 30. So all the we have elements 20, 10, 15. Now this is the next free space. Right. 20, 10, 15. Next free space we have 30. So 30 we are going to insert 30. This is complete by entry but not some max heap. Adjust the element. Compare with the parent and its parent. So 30 is greater than 10 and also greater than 20. So 10 will come at the place of 30. Yes. Here it is compared with this one. Then again it is compared with 20. So 20 comes here and at this place 30 will be inserted. So this will modify. 10 comes here 20 here and this becomes 30. Now this is a heap till here. So we have 4 elements in a heap. Now the last element 40 I am going to insert. So right now we have 30, 20, 15 and 10. So 30, 20, 15 and 10. So the new element that we are inserting is 40 here. So 40 is inserted at next free space here. So it is a complete by entry but not a max heap. Compare with the parent. Yes. 40 is greater. Then its parent. 40 is greater than that also. So 40 will move up. So this is the parent. 5 by 2 is 2. Then its parent. So yes. 20 will go at this place and 30 will go at this place and 40 comes here. So it means 20 comes here, 30 comes here and 40 is here. So this is a max heap. So one by one we have inserted all the elements and every element was inserted at a next free space and it was moved upwards and we got a max heap. Now before going to the next step let us analyze how much time it has taken. We have inserted an elements total and elements we have inserted. How much time it takes for inserting an element in a heap depends on the height. What is height of a complete monetary or a heap? It is login. So an element each element we assume that it is moved up to the root so it is login. So the time taken is n log n. So this was the heap creation first step. Now from that heap I will be going on deleting the elements. So this place I will show you how the elements are deleted and they are also sorted. So let us delete the elements. Now second step for heap sort. Already we have created a heap. Now the same heap I have taken this is the heap that we got. Now let us delete the element. So we know very well how to delete the element. So in this let us delete. So which element get deleted? 40 gets deleted. 40 is gone then who will take its place? Last 20. This will take its place. 20 will take its place. So in the diagram I will show 40 is removed and 20 will go in its place. 20 will go in its place. So it means this element is gone. This element is gone. Now this is complete monetary but not a max heap. So we have to adjust. We have to adjust downward. So this 20 is gone. 20 is removed. Now 30 and 15. 30 is greater. So 30 will go in the place of 20 and 20 will come here. So this becomes 20 and this becomes 30. Then again compare 20 with 10. So it is perfect. So these are the changes. So now 40 is deleted and we got one free space. Now here I will show I will add the elements. See we have 30 here and 20 here 15 and 10. So the elements in the heap are 30, 20, 15 and 10. Heap is 10 4 elements only. 40 which was deleted I will put it here at a free space. That is not a part of heap. Now delete next element. So next element which element will be deleted? 30 will be deleted. 30 is gone. Who will take its place? Last element in complete monetary. 10. So in this array 30 is gone. So the 10 last element will come here. This element came here. So this is not there. So one more element reduced. We have to adjust this one. Compare with the children. 20 is greater. So 20 moves up and 10 comes down. So this becomes 20 and this becomes 10. So this is deleted. I will remove this arrow. Now 30 is deleted and this is in a max heap form. Now next step here I will show. We have the elements 20, 10 and 15 and heap is ending here. 40 was already there. We got one more free space. So keep 30 there. The newly deleted element and in the diagram this is 20, 10 and 15. Still we have to delete three more elements. Now next delete one more element. Which element get deleted? 20 is deleted. From the array this is gone. Who will take its place? Last element in complete monetary will take its place. 15. So 15 will come here. Last element in the array that is in the heap. 15 comes here. So this place is free. So this is gone. Now adjust. Already 15 is greatest. So child is smaller. No need to swap the element. It's already perfect. So this is the result. Then next space I will write down. This is 15 and this is 10. So this is 15 and 10 and heap is ready. Still here. See there were three elements. Now there are only two elements. Already I have 40 at the last and 30 at the second last place. One more free space I got. There I can insert 20. So just a stored 20. I should not say insert. Just I have stored 20 there. Captured 20 there. Now these elements are deleted from the heap. These are remaining still in the heap. Not delete next element. Which element is deleted? 15 is deleted. Who will take its place? Last element. So it means this is gone. So here also 15 is gone. 10 will take its place. Now we have to adjust. You don't have to adjust anything. Now what will be the result? This is 10. So this is 10. Now heap ends here. Now we already have 20, 30 and 40 here. We got one free space. So there you store 15. So that's how the elements are sorted. So the heap sawed. First step. If the elements are given then create a heap. Then second step. Go on deleting the element and store the element at a free space. We are obtaining after deleting the element. So finally the elements are sorted. So you look at this. So you have to observe it because too much board work is there. Lot of board work is there. So you may miss at some place. So I suggest you just pause the video and have a look at it complete. Example is there on board. And do it by yourself. Once you do it by yourself then you can remember it always. How it is working. Just take a snapshot or copy everything from the board. If we do the analysis already creation process we have seen and log n. Creating heap and log n. Now how much time does it deleting of all any and element is taking. An elements we are deleting and each element takes how much time. For deletion also it takes log n time. We have already seen it. So that is n log n. So n log n for creation n log n for deletion. So total how much to n log n and this is big of n log n. Two times of log n is also dependent on n log n. So the time is order of n log n or big of n log n. So heap sort takes n log n time. So that is it. This is heap sort. Now I have to explain you heapify. And heapify is a process of creating a heap. Already we have created a heap. How it is different. It is different. How it is different we will see but before that if you remember here we were inserting the element always in the leaf and we were adjusting towards root. Adjusting towards root. It was sent from leaf towards root. Adjustment was upward. Now in heapify the direction is different. How it is done I will show you. Remove this and show you. Now heap next topic is heapify. Heapify is a procedure for creating a heap. So already we saw how to create a heap by inserting elements one by one. Here also we will do the same thing. But the procedure was inserting an element in the leaf and adjusting upwards. Now let us see how heapify works. So for explaining heapify already I have an array. And if you see it diagrammatically it is a binary tree and it is a complete binary but it is not a max heap. We want max heap. Now if we just repeat the procedure of creation let us look at it quickly. Already we saw in creation process what we did we kept 10 as it is inserted 20, 20 went up. Then inserted 15 then inserted 12 then 40 then 25 then 18 one by one we inserted starting from this element. So we inserted except this element we inserted 20 15 12 40 25 18. So we started from left to right. Is it possible if we change the direction can we create a heap let us start from right to left. So if we start from right to left then shall we still adjust the element upward? No let us do it downward. Downward how? In the deletion if you remember we were adjusting the element by sending it down towards leaf from root. So the direction was from top towards leaf that procedure will follow. Let us follow the procedure. Now I am explaining heapify watch this. First go to element 18. Look down there are no children. So only a single element don't look at all other nodes just 18 and its descendants there are no descendants. So 18 is a heap. Yes then go to next element 25 25 look downwards it's a heap there is nothing there are no children it's alone it's a heap. 40 is a heap next element 40 next element 12 downwards it's a heap now you will understand what does it mean what I was saying just next next element 15. So from here adjust 15 downwards yes children are there compare which is greater 25 so 25 will go up and 15 will come down yes this is the procedure 25 will go up and 15 will come down so 25 will go up and 15 will come in its place this one right. So if you look only these nodes 25 15 and 18 it's a heap yes only one element I have adjusted now next after 25 this one 20 is there this is over right 15 was there this is over now we are on second element right this one look downwards is it a max heap no adjust this one so compare with the children 40 is greater so 20 will come here 40 will go up right so 40 this will be changed to 20 and this will become 40 so I have just adjust just two elements now the after second element first element here only this element is not in a heap so adjust it compare with the children 40 is greater so 40 goes up 10 comes here compare with the children 20 is greater so 20 goes up 10 comes here right so this will be swapped with the child so this will become 40 and this is 10 then again swap with the children that is 20 and 10 12 and 20 was there so it will be swap with 20 and this comes here this is a heap so we adjusted the elements downwards and we started from the last element so we have scanned this array from right to left the procedure we were using in the deletion after deletion we were adjusting the elements same procedure we followed and we got the heap created so this procedure is called as heapify direction is different that's all right and what's the time taken by this one analytically the time taken by this heapify procedure is big of n big of theta omega whatever you want notation you use anything commonly we use big so this is big of n so if you remember the procedure for creating a heap creating a heap so creating a heap was analog n big of n log n right but this is heapify heapify procedure is order of n so this is faster now what is the minimum time taken for creating a heap big of n using heapify so that's all about heapify now the last thing is what are priority cues it's a simple topic so I will finish with that one next we will see priority cues now priority cue priority cue so actually cuements fee 4 but priority cuements it's not fee 4 strictly the elements will have priority and they are inserted and deleted based on the priority right so always if in a queue when you want to delete always we want highest priority element from the queue the element having the highest priority that should be deleted for so this is the discipline of priority cue elements are inserted with their priority when you delete we want higher priority element so let us see what does it mean by higher priority see these are the numbers what is the priority of a number number it's self is the priority okay here in our example number itself is the priority there are other example of priority cues also like in operating system also there is a concept of priority cue it's not same as that one this priority cue is mostly used in algorithms right so let us see what is the priority 8 is the priority of 8 6 is the priority of 6 so 10 is the priority of 10 so that number itself is the priority then who is higher priority I can say that smaller number higher priority so which is highest priority this one then this one right then this one yes smaller the number higher the priority so 3 is of highest priority here so if I delete I want 3 from the array then otherwise even I can say that larger the number higher priority I can say this also so larger number higher priority so who is having higher priority 10 then 9 then 8 so yes when I want delete I should get 10 from that one so this is about priority cue elements they value itself is priority and there are two methods of giving priority smaller number higher priority or larger number higher priority okay now let us see how to insert and delete see in an array if I want to insert suppose I have one more element simply I can insert after this one then I when I want to delete from the this type of priority cue I want to 3 then 4 how much time it takes for deleting an element from an array order of n because if I am deleting 3 I should shift the rest of the elements the rest of the elements I should shift so it takes order of n time so if you implement priority cue just using normal array then the time for insert or delete maybe order of n so I do not want to discuss in detail you can study it by yourself means you can analyze by yourself if you say no I want to keep them sorted order then for sorting also it takes time again for deletion or insertion you have to spend order of n time then what is the better method heap which takes how much time log n time for insertion and log n time for deletion so yes heap is a best data structure for implementing priority cue so if you have smaller number higher priority then creator mean heap if you have larger number higher priority then use max heap same set of numbers I have created already created a mean heap already created max heap so for one element insertion how much time it takes log n right then one element deletion how much time it takes log n so this is the best data structure which works faster otherwise if you use normal array like this then insertion may take order of n time maybe deletion is faster otherwise deletion will take order of n time and insertion may be faster any one of the operation will definitely take order of n time but in heap the time taken is log n so heap is a faster data structure for implementing priority so that's all about priority cue so predicate can be implemented using heap so either mean heap or max heap if you want always smaller number mean heap if you want always larger number max so that's all in this video and if you want to take the course you can check in the description and you can buy the course for C++ and data structure subject there are two different courses right so go through the course see the contents and then you decide that's all