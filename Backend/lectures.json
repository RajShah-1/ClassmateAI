{
    "31a2da90-c458-4198-8658-296418d51b0d": {
        "lectureID": "31a2da90-c458-4198-8658-296418d51b0d",
        "lectureTitle": "Variables and Data Types",
        "audioPath": "",
        "uploadDate": "",
        "duration": "",
        "transcript": "",
        "summary": "",
        "summaryStatus": "NOT_STARTED",
        "lastUpdated": "2025-03-07T21:14:46.936405"
    },
    "04ee0fde-5d80-48f0-a79b-586d2a88047d": {
        "lectureID": "04ee0fde-5d80-48f0-a79b-586d2a88047d",
        "lectureTitle": "Variables and Data Types",
        "audioPath": "",
        "uploadDate": "",
        "duration": "",
        "transcript": "",
        "summary": "",
        "summaryStatus": "NOT_STARTED",
        "lastUpdated": 1741382371.051287
    },
    "b6ae4289-bcfd-4d48-96be-329c76a1fa1b": {
        "lectureID": "b6ae4289-bcfd-4d48-96be-329c76a1fa1b",
        "lectureTitle": "Introduction to Machine Learning",
        "audioPath": "",
        "uploadDate": "",
        "duration": "",
        "transcript": "",
        "summary": "",
        "summaryStatus": "NOT_STARTED",
        "lastUpdated": 1741481617.562199
    },
    "ba04a7b5-a66d-4d33-a1c9-5102f5a0c713": {
        "lectureID": "ba04a7b5-a66d-4d33-a1c9-5102f5a0c713",
        "lectureTitle": "Teww",
        "audioPath": "",
        "uploadDate": "",
        "duration": "",
        "transcript": "",
        "description": "Lecture on Teww",
        "summary": "",
        "summaryStatus": "NOT_STARTED",
        "lastUpdated": 1741485312.78866
    },
    "016235ae-e5d7-45d6-a01d-4e65a353f800": {
        "lectureID": "016235ae-e5d7-45d6-a01d-4e65a353f800",
        "lectureTitle": "Three",
        "audioPath": "uploads/016235ae-e5d7-45d6-a01d-4e65a353f800.mp3",
        "uploadDate": 1741485330.634238,
        "duration": 1199.7257142857143,
        "transcript": " Alright, we are back. Alright, so today what we're going to do is we're going to go over our binary tree fundamentals. And yes, I know maybe you're already familiar with this, but my goal is to make this channel one of the world's largest resources for software engineering interviews and this kind of preparation. So the key is we have to go through our fundamentals and get them very solid before we can build on top of them and do other topics. So if you haven't subscribed to the channel, subscribe to the channel and like this video. What we're going to do today is we're going to talk about our fundamental traversals of binary structures, binary tree structures, and we're going to talk about the types of trees. We're just going to go over our very basic concepts so that we have them very solid. So let's go over three of the key kinds of trees or three terms we can use to describe a tree. If we have a tree where leaf notes have no children or a node has two children, it is a full tree. Notice, this is a leaf, it has no children. This is a leaf, it has no children. This is a leaf, it has no children, and that is a leaf, it has no children. But the nodes that do have children have two children. They cannot have one chip child. They have to have two children. So this tree is full. Every time we decide to have a descendant, we have to have two descendants. We can't just have one. So this node decided, I'm going to have descendants. I need to have two. This node said, I'll have no descendants. It has no descendants, no children. That is a full tree and you can tell by what it looks like. So this is a complete binary tree. Complete binary trees are our binary heaps. We make binary heaps complete trees. So what does complete mean? All it means simply is when we fill out the nodes, we go top to bottom, we go left to right. Do you see how we go and fill it out like this? Do you see how we go top to bottom? And do you see how we go from left to right? And if I just put a node right here, just out of the blue, I stuck a node in there. This tree is no longer complete because I just missed putting a node there. So this is a complete binary tree. And then finally, we have our perfect binary tree. So a perfect binary tree is where all the leaves are on the same level and all of the nodes that decide to have descendants have exactly two children. A perfect binary tree is both complete and it is also full. You see how the nodes that decided to have children decided to have descendants. They only can have two children. They can't just have one child. But the ones that did not decide have no children. And notice how all of the ones that did not decide what we call leaves are all on the same level. This is a perfect binary tree. So now that we understand our terminology very soundly, what we need to do is let's look at these traversals and yes, these are going to be the raw traversals you can do on a tree. But it's very key to understand these traversals so we can adapt them to other problems. If we're very flexible with traversing a binary structure, it becomes much easier to solve problems recursively or iteratively with a stack. So let's look at our traversal now. Okay, so what we're going to do is we're going to do a traversal of this tree and there are three fundamental ways to traverse a binary tree. You can do it other ways, but these are the three key ways. There's your pre-order traversal, your in-order traversal and your post-order traversal. And I don't want you to worry about the part in the word where it says order. I only want you to notice the first part of the word. Notice how it says pre. Notice how it says in. Notice how it says post. That prefix, the prefix to the name of the traversal tells us when we visit the node we're sitting at. So what I want you to see is in a pre-order traversal, in a pre-order traversal, we visit the node, we visit the left subtree, we visit the right subtree. Do you see how it's called pre-order? Do you see how the n is the first visited? Do you see how it's pre before the left and right? So for in-order, think of it as in. So left subtree, visit the node and then visit the right subtree. So do you see how it's in? Do you see how it's in the middle? That's how you remember in order traversal. And then we have our post-order traversal. We go left subtree, we go right subtree, we visit the node. So do you see how it's post? It's after the left and right. So the left and right stay in sequence, left and right stay in sequence, but the prefix tells us when we visit the node before the subtree. So subtree will be left to right. But when do we visit the node? That's what the prefix tells us. So what we're going to do is we'll do a pre-order, we'll do an in-order, and then we'll do a post-order traversal here. So this is what I want you to think about when we're traversing a tree. I'm going to write something that's going to help you. So I want you to think of recursion. Think of recursion as a certain policy. We have to execute at each node. Think of the recursion as the tasks we need to do it a node and the state, the state stays on the call stack. This is the key with recursion. So do you see how I just put node left right? This is our pre-order. We're doing pre-order right now. And what we want to do is we want to execute the policy at each node. So what we do is we start at the 10. I see I have to do a node visit, I have to do a left subtree visit, I have to do a right subtree visit. So what I'm going to do is I'm going to do the node visit. I'm going to just output 10. And what I'm going to do is I'm going to erase the end. So I'm just familiarizing you with the example that we're walking through. And notice we don't just have to print a node. We can do any form of work. The whole point is visitation. We want to get our fundamentals down for visiting a node right now. So what we're going to do is we're going to execute our policy at the stack frame. We're going to say I need to visit my left. So this stack frame says I need to visit the left subtree. So we're going to circle the left. Okay, so now we recurse and now we just circled the left and now we're going to come down and we'll come to the 7. What is the policy at 7? 7 says okay, what do I need to do here in my stack frame? So what we see is we see that 7 has to we see that 7 has to do we see that 7 has to do at node visitation. So what we're going to do is we're going to visit 7. And notice the next step in 7's policy in this stack frame is to visit the left subtree. So let's do it. So we visit the left subtree. And now what we need to do is we need to do this policy at this stack frame. So do you see how recursion is we're executing the same policy at each node, but it's going to give us the behavior we desire because of the way we're ordering the visitations, right? So what we're going to do is we'll visit the 6. And then we're going to recurse and then we're going to come to the 1. We're going to visit the 1. And then 1 says I need to visit my left subtree. We hit a base case, nothing. We come back. 1 says, OK, I finished my left. So I can erase that. I'm done. And then what is one's policy? What is the policy at this stack frame? What is left for this recursion in this stack frame to finish? And we see all that's left is visit the right subtree. Let's visit the right subtree. And then we see that there's nothing. So we come back and now 1 has nothing to do. So now we return to our caller. And now 6 says, OK, thank you, left subtree. You're finished now. What is next and 6's stack frame? And again, I say stack frames, but the thing is we don't have to use the call stack. We could make our own stack. We can make our own stack and then we could execute the traversal that way. So it just depends on the traversal and what implementation you want to do. So this says I need to visit my right. So the 6 visits is right. There's nothing there. So 6 comes back. So now 6 has nothing to do. It returns to its caller 7. In 7's stack frame, in its policy, it's stack frame, it says I visited my left. And now all 7 has to do is visit its right subtree. There's stuff to do over here. So let's do that. So now 8 says, what do I need to do? What does 8 need to do? It needs to visit itself. It needs to visit its own note. And then it needs to go left. We see there's no left. And then 8 says, OK, I need to go right now. So we recurse on the right subtree and now we're at 9. What is 9's policy? What is 9's job? And I want you to drill this in your brain because this is how we really understand recursion. This is how we really see that recursion expresses our decisions at each note. It's different for each note. Each note has a different state. Do you see how state differs? This is a recursion. Fundamental I want you to internalize. So we see 9. So what we need to do is we need to print 9. We see it has to print itself. And so 9 needs to visit its left. Nothing. 9 needs to visit its right. Nothing. So it has nothing left. We return to the 8. The 8 finished its right subtree. Nothing left. 8 has nothing to do left. And now we come back to 7. 7 was just visiting its right subtree. 7 says, OK, I'm finished. 7 is finished. And now we return to 10. And do you see how this all was the left subtree of 10? Do you see how our next task is to explore the right subtree of 10? So all the traversals do is they change how we traverse this tree. They change when we visit nodes. What we do is we check the right subtree and then what we need to do is we need to print 11 because 11 has that task to do. And so 11 has to visit its left. There's nothing here. So we come back to 11. And so 11 has to visit its right. And so 11 visits its right. And now 20 comes to itself. And 20 says, what do I need to do here? I need to print myself. Go left and right. So 20 will print itself. So 20 now needs to go left. So it comes to 14. 14 needs to print itself. And now 14 will go to the left. So 14 finds nothing. It'll go to the right as well. It'll find nothing. And now back to 20. What was 20 just doing? It was looking to its left. So what we're going to do is we're going to finish that. What is the next state in 20's stack ring? Well, we need to go to the right. We come to the right and we see 22. So we see 22 and 22's job. Well, it hasn't printed itself. It hasn't gone left. It hasn't gone right. It needs to do its job. So we're going to print 22. And then we'll go left. There's nothing. And then we'll go right. There's nothing. 22 is finished. It returns to 20. And then 20 has explored its right. It'll finish. 20 has nothing left to do. It'll return to 11. 11 has finished its right. So 11 has nothing to do. It's going to return to 10. 10 has finished its right. And 10 stack frame. The top level stack frame that drove us into the recursion is finished. We're going to return to our caller, whatever we return, whether it's the count of the nodes or something. And that is finished. That is the traversal of the tree. This is what their pre-order traversal looks like. The key is you don't really need to memorize these traversals. You literally can get the hint of what they are from the name. Anyway, I think you get the idea now. Let's go through the in-order and post-order and see how those work out. They're basically the same thing. So now what we're going to do is we're going to do an in-order traversal. And all that changes is we're going to do a different policy at each node. So let's define that policy. Okay, so now all we did was define a different policy. So we're going to go left. We're going to visit the node we're sitting at. And then we're going to go right. That is all that we're going to do different. So what we're going to do is we're going to start at the 10. The 10 will be called by an external caller and we're going to kick off our recursion. What we're going to do is we're going to execute a policy at 10. And when you really to internalize this, that recursion at each frame, every frame has a different state. Although every frame has the same policy, every frame will have a different state at different points in the recursion. So we're going to go left at 10. And then we come to 7. What does 7 need to do? 7 needs to go left. What will 6 do? 6 needs to go left. What will 1 do? 1 needs to go left. And 1 is going to go left. There's nothing there. It comes back. And so what does 1 need to do? 1 needs to print itself. So 1 printed itself. And after a printed self, it needs to go right. There's nothing there. And now what we need to do is come back. We come back to 6 because 1 is finished. We come back to 6. So 6 just finished up going left. So now 6 needs to print itself. So now 6 needs to go right. We see that there is nothing to 6 is right. So what we're going to do is we're going to just return to 7. We have nothing else to do at 6. So 7 just finished going left. So 7, it's next job in its stack frame is to print itself. So now 7 needs to go right. And now 8 needs to go left. We see in its stack frame, that's his first job. And then it goes left. It finds nothing. And then 8 needs to print itself. And then 8 needs to go right. And then 8 goes right. And then we see 9 needs to go left. There's nothing there. 9 needs to print itself. And then 9 needs to go right. There's nothing there. 9 has nothing to do. It returns to 8. And 8 has finished its right subtree. 8 has nothing to do left. So 8 returns to 7. 7 is finished. It's right subtree. So 7 returns to 10. 10 has finished. It's left subtree. All that work we were doing was on the left subtree. So now 10 needs to print itself. And now 10 needs to go to its right. And now 11 needs to go to its left. There's nothing to 11's left. It needs to come back to itself. And now 11 needs to visit itself. And then 11 goes to the right. 20. What does it need to do? It needs to go to the left. 14 needs to go to the left. There's nothing there. 14 needs to visit itself. And then we see 14 needs to go right. There's nothing there. So 14 returns to whoever called in which was 20. 20 is done going left. 20 needs to visit itself next. And then 20 needs to go to the right. And then we reach 22. 22 needs to go left to visit itself and go right. So it goes left. There's nothing. Comes back. It needs to print itself. And now 22 needs to go right. There's nothing there. We return to 20. 20 is finished. 20 returns to its caller. Its caller has finished its right subtree. 11 returns to its caller. 10. 10 has finished its right subtree. And we are finished printing it. And I want you to notice there's something special about this. What we just did. There's something special right here because do you notice how these are in increasing order? This tree is a special kind of tree called a binary search tree. So the nature of the way these nodes are oriented is this node is in the middle of all of these guys and all of these guys. So if we go to the left, we go lesser in value. We go less than 10. Everything in the left subtree is less than 10. Everything in the right subtree is greater than 10. So this is a special kind of tree. Again, a binary search tree. You're probably already familiar with this if you are watching this. But anyway, so now I think you really get the idea. But just to drill it in, let's do the post order traversal. Okay, so now we're going to do the post order traversal and nothing changes. Nothing changes except our policy at each node. The way we visit the nodes. So let's just go straight through this and you should be pretty rapid with this now. So what we're going to do is we're going to go to the left first. For 10, we'll go left first and then seven will go left. Six will go left. And this is starting to look like the in order traversal. But let's continue. So one, go to the left. We go to the left and we see that we don't find anything. So we come back and this is the way this differs from our in order traversal. Instead of visiting ourselves next, the next task is to visit our right subtree. Remember, this is a post order traversal. We visit ourselves a post last, right? So what we're going to do is visit our right. There's nothing there. And then we'll visit ourselves and what we're going to do is print ourselves. There's nothing left to do at one. So what we'll do is return to our collar six. So six needs to go to the right. There's nothing there. So we come back. And so six needs to visit itself. So we print six. Six is finished. So six returns to its collar. We see its collar was seven. Seven just finished up its left subtree. So now seven goes to the right. Seven goes to the right and we come to eight. What does eight need to do? Eight needs to go to the left to the right and to itself. So we go left. There's nothing here. So we come back to eight. So eight now needs to explore its right. And so now eight is exploring its right. We come to the nine. So nine needs to explore its left. There's nothing there. So now nine needs to explore its right. There's nothing there. So now nine only needs to print itself. Nine returns to its collar. Eight. Eight realizes its finished its right subtree. And now eight needs to print itself. Eight has nothing left to do. It returns to seven. Seven. All he needs to do is print itself. Seven has nothing left to do. It returns to its collar. Ten. Ten finished its left subtree. All it has to do is go right. And now we come to eleven. Eleven needs to go to the left. Eleven does not have anything on his left. So eleven goes right. We come to twenty. Twenty needs to go left to right and visit itself. We go to the left. We come to fourteen. We go to the left. There's nothing. We go to the right. There's nothing. We visit the node fourteen. That's the last task in our stack frame. We visit fourteen. We come back to twenty. Twenty has exhausted its left subtree. So twenty's next task is to go to the right. So now we're going to go to the right. We see twenty two. Twenty two's job is not to print itself. It's to go left to go right and then print itself. So now twenty two's going left. There's nothing there. It needs to go right. There's nothing there. It needs to print itself now. We come back to our collar twenty. It's finished exploring its right subtree. Now twenty needs to print itself. Twenty is finished with its tasks. So it comes back to eleven. Eleven realizes I'm done with my right subtree. Eleven needs to print itself now. And now eleven has nothing to do. We return to our collar. And now we have ten. Ten realizes I'm done with my right subtree. And now finally ten prints itself. Ten realizes it has nothing left to do. And we've completed our traversal. That is our post order traversal. That is basically how you do it. See the thing is you don't always have to do this recursively. But what we're going to do is there's a certain way we need to visit these nodes. And however we structure our recursion, however we structure our stack, what items we push and what order is going to change how we visit these nodes. It's not that scary to deal with binary structures, binary tree structures because as long as we know our fundamentals, as long as we know how to visit nodes, we can be very flexible in how we deal with these structures. I haven't even gotten into breadth-restriversal. We can do a zigzag traversal. We would use a queue for that. But that's for another video. But I just want to introduce this concept. You're probably already familiar with this. If we are thinking about complexities, if we think about any of these traversals where we're touching all of the nodes, if N is the number of nodes, then the upper bound we can set on the time we're taking is going to be linear time. We're going to scale in a linear fashion as our tree gets bigger if we're touching all of the nodes. Anyway, we're going to get more familiar with tree complexities and all that. It gets fairly straightforward as you do more problems. But that is all for this video. If you liked this video, hit the like button, subscribe to the channel. This was a very basic fundamental one. Of course, we have a table of content so you can skip through this. I would do not expect anyone to watch all of this. But that is all for this video. And what I'm going to do. And um...",
        "description": "Lecture on Three",
        "summary": "So this node decided, I'm going to have descendants.\nAll it means simply is when we fill out the nodes, we go top to bottom, we go left to right.\nAnd do you see how we go from left to right?\nSo now that we understand our terminology very soundly, what we need to do is let's look at these traversals and yes, these are going to be the raw traversals you can do on a tree.\nOkay, so what we're going to do is we're going to do a traversal of this tree and there are three fundamental ways to traverse a binary tree.\nSo what I want you to see is in a pre-order traversal, in a pre-order traversal, we visit the node, we visit the left subtree, we visit the right subtree.\nDo you see how it's pre before the left and right?\nSo left subtree, visit the node and then visit the right subtree.\nWe go left subtree, we go right subtree, we visit the node.\nIt's after the left and right.\nSo the left and right stay in sequence, left and right stay in sequence, but the prefix tells us when we visit the node before the subtree.\nSo subtree will be left to right.\nSo what we're going to do is we'll do a pre-order, we'll do an in-order, and then we'll do a post-order traversal here.\nThink of the recursion as the tasks we need to do it a node and the state, the state stays on the call stack.\nSo do you see how I just put node left right?\nI see I have to do a node visit, I have to do a left subtree visit, I have to do a right subtree visit.\nSo what I'm going to do is I'm going to do the node visit.\nWe want to get our fundamentals down for visiting a node right now.\nWe're going to say I need to visit my left.\nSo this stack frame says I need to visit the left subtree.\nOkay, so now we recurse and now we just circled the left and now we're going to come down and we'll come to the 7.\nAnd notice the next step in 7's policy in this stack frame is to visit the left subtree.\nSo we visit the left subtree.\nSo do you see how recursion is we're executing the same policy at each node, but it's going to give us the behavior we desire because of the way we're ordering the visitations, right?\nSo what we're going to do is we'll visit the 6.\nWe're going to visit the 1.\nAnd then 1 says I need to visit my left subtree.\nWhat is left for this recursion in this stack frame to finish?\nAnd we see all that's left is visit the right subtree.\nLet's visit the right subtree.\nSo this says I need to visit my right.\nSo the 6 visits is right.\nIn 7's stack frame, in its policy, it's stack frame, it says I visited my left.\nAnd now all 7 has to do is visit its right subtree.\nAnd then it needs to go left.\nSo we recurse on the right subtree and now we're at 9.\nAnd so 9 needs to visit its left.\n9 needs to visit its right.\nThe 8 finished its right subtree.\n7 was just visiting its right subtree.\nWhat we do is we check the right subtree and then what we need to do is we need to print 11 because 11 has that task to do.\nAnd so 11 has to visit its left.\nAnd so 11 has to visit its right.\nAnd so 11 visits its right.\nGo left and right.\nSo 20 now needs to go left.\nWell, we need to go to the right.\nSo now what we're going to do is we're going to do an in-order traversal.\nAnd all that changes is we're going to do a different policy at each node.\nSo we're going to go left.\nWe're going to visit the node we're sitting at.\nAnd then we're going to go right.\nSo we're going to go left at 10.\nAnd 1 is going to go left.\nSo 6 just finished up going left.\nSo now 6 needs to go right.\nWe see that there is nothing to 6 is right.\nSo 7 just finished going left.\nSo now 7 needs to go right.\nAnd then 8 needs to go right.\nAnd then 9 needs to go right.\nAnd 8 has finished its right subtree.\nAnd now 10 needs to go to its right.\nAnd then we see 14 needs to go right.\n20 is done going left.\nAnd then 20 needs to go to the right.\n22 needs to go left to visit itself and go right.\nAnd now 22 needs to go right.\n10 has finished its right subtree.\nOkay, so now we're going to do the post order traversal and nothing changes.\nInstead of visiting ourselves next, the next task is to visit our right subtree.\nWe visit ourselves a post last, right?\nSo what we're going to do is visit our right.\nAnd then we'll visit ourselves and what we're going to do is print ourselves.\nSo six needs to go to the right.\nEight needs to go to the left to the right and to itself.\nAll it has to do is go right.\nTwenty needs to go left to right and visit itself.\nWe go to the right.\nSo now we're going to go to the right.\nIt's to go left to go right and then print itself.\nSo now twenty two's going left.\nIt needs to go right.\nBut what we're going to do is there's a certain way we need to visit these nodes.\nAnd however we structure our recursion, however we structure our stack, what items we push and what order is going to change how we visit these nodes.",
        "summaryStatus": "COMPLETED",
        "lastUpdated": 1741485377.986125
    },
    "87c5dd7a-b5d0-43fc-8e70-e9503482ef84": {
        "lectureID": "87c5dd7a-b5d0-43fc-8e70-e9503482ef84",
        "lectureTitle": "Trees",
        "audioPath": "uploads/87c5dd7a-b5d0-43fc-8e70-e9503482ef84.mp3",
        "uploadDate": 1741485449.861521,
        "duration": 1199.7257142857143,
        "transcript": " Alright, we are back. Alright, so today what we're going to do is we're going to go over our binary tree fundamentals. And yes, I know maybe you're already familiar with this, but my goal is to make this channel one of the world's largest resources for software engineering interviews and this kind of preparation. So the key is we have to go through our fundamentals and get them very solid before we can build on top of them and do other topics. So if you haven't subscribed to the channel, subscribe to the channel and like this video. What we're going to do today is we're going to talk about our fundamental traversals of binary structures, binary tree structures, and we're going to talk about the types of trees. We're just going to go over our very basic concepts so that we have them very solid. So let's go over three of the key kinds of trees or three terms we can use to describe a tree. If we have a tree where leaf notes have no children or a node has two children, it is a full tree. Notice, this is a leaf, it has no children. This is a leaf, it has no children. This is a leaf, it has no children, and that is a leaf, it has no children. But the nodes that do have children have two children. They cannot have one chip child. They have to have two children. So this tree is full. Every time we decide to have a descendant, we have to have two descendants. We can't just have one. So this node decided, I'm going to have descendants. I need to have two. This node said, I'll have no descendants. It has no descendants, no children. That is a full tree and you can tell by what it looks like. So this is a complete binary tree. Complete binary trees are our binary heaps. We make binary heaps complete trees. So what does complete mean? All it means simply is when we fill out the nodes, we go top to bottom, we go left to right. Do you see how we go and fill it out like this? Do you see how we go top to bottom? And do you see how we go from left to right? And if I just put a node right here, just out of the blue, I stuck a node in there. This tree is no longer complete because I just missed putting a node there. So this is a complete binary tree. And then finally, we have our perfect binary tree. So a perfect binary tree is where all the leaves are on the same level and all of the nodes that decide to have descendants have exactly two children. A perfect binary tree is both complete and it is also full. You see how the nodes that decided to have children decided to have descendants. They only can have two children. They can't just have one child. But the ones that did not decide have no children. And notice how all of the ones that did not decide what we call leaves are all on the same level. This is a perfect binary tree. So now that we understand our terminology very soundly, what we need to do is let's look at these traversals and yes, these are going to be the raw traversals you can do on a tree. But it's very key to understand these traversals so we can adapt them to other problems. If we're very flexible with traversing a binary structure, it becomes much easier to solve problems recursively or iteratively with a stack. So let's look at our traversal now. Okay, so what we're going to do is we're going to do a traversal of this tree and there are three fundamental ways to traverse a binary tree. You can do it other ways, but these are the three key ways. There's your pre-order traversal, your in-order traversal and your post-order traversal. And I don't want you to worry about the part in the word where it says order. I only want you to notice the first part of the word. Notice how it says pre. Notice how it says in. Notice how it says post. That prefix, the prefix to the name of the traversal tells us when we visit the node we're sitting at. So what I want you to see is in a pre-order traversal, in a pre-order traversal, we visit the node, we visit the left subtree, we visit the right subtree. Do you see how it's called pre-order? Do you see how the n is the first visited? Do you see how it's pre before the left and right? So for in-order, think of it as in. So left subtree, visit the node and then visit the right subtree. So do you see how it's in? Do you see how it's in the middle? That's how you remember in order traversal. And then we have our post-order traversal. We go left subtree, we go right subtree, we visit the node. So do you see how it's post? It's after the left and right. So the left and right stay in sequence, left and right stay in sequence, but the prefix tells us when we visit the node before the subtree. So subtree will be left to right. But when do we visit the node? That's what the prefix tells us. So what we're going to do is we'll do a pre-order, we'll do an in-order, and then we'll do a post-order traversal here. So this is what I want you to think about when we're traversing a tree. I'm going to write something that's going to help you. So I want you to think of recursion. Think of recursion as a certain policy. We have to execute at each node. Think of the recursion as the tasks we need to do it a node and the state, the state stays on the call stack. This is the key with recursion. So do you see how I just put node left right? This is our pre-order. We're doing pre-order right now. And what we want to do is we want to execute the policy at each node. So what we do is we start at the 10. I see I have to do a node visit, I have to do a left subtree visit, I have to do a right subtree visit. So what I'm going to do is I'm going to do the node visit. I'm going to just output 10. And what I'm going to do is I'm going to erase the end. So I'm just familiarizing you with the example that we're walking through. And notice we don't just have to print a node. We can do any form of work. The whole point is visitation. We want to get our fundamentals down for visiting a node right now. So what we're going to do is we're going to execute our policy at the stack frame. We're going to say I need to visit my left. So this stack frame says I need to visit the left subtree. So we're going to circle the left. Okay, so now we recurse and now we just circled the left and now we're going to come down and we'll come to the 7. What is the policy at 7? 7 says okay, what do I need to do here in my stack frame? So what we see is we see that 7 has to we see that 7 has to do we see that 7 has to do at node visitation. So what we're going to do is we're going to visit 7. And notice the next step in 7's policy in this stack frame is to visit the left subtree. So let's do it. So we visit the left subtree. And now what we need to do is we need to do this policy at this stack frame. So do you see how recursion is we're executing the same policy at each node, but it's going to give us the behavior we desire because of the way we're ordering the visitations, right? So what we're going to do is we'll visit the 6. And then we're going to recurse and then we're going to come to the 1. We're going to visit the 1. And then 1 says I need to visit my left subtree. We hit a base case, nothing. We come back. 1 says, OK, I finished my left. So I can erase that. I'm done. And then what is one's policy? What is the policy at this stack frame? What is left for this recursion in this stack frame to finish? And we see all that's left is visit the right subtree. Let's visit the right subtree. And then we see that there's nothing. So we come back and now 1 has nothing to do. So now we return to our caller. And now 6 says, OK, thank you, left subtree. You're finished now. What is next and 6's stack frame? And again, I say stack frames, but the thing is we don't have to use the call stack. We could make our own stack. We can make our own stack and then we could execute the traversal that way. So it just depends on the traversal and what implementation you want to do. So this says I need to visit my right. So the 6 visits is right. There's nothing there. So 6 comes back. So now 6 has nothing to do. It returns to its caller 7. In 7's stack frame, in its policy, it's stack frame, it says I visited my left. And now all 7 has to do is visit its right subtree. There's stuff to do over here. So let's do that. So now 8 says, what do I need to do? What does 8 need to do? It needs to visit itself. It needs to visit its own note. And then it needs to go left. We see there's no left. And then 8 says, OK, I need to go right now. So we recurse on the right subtree and now we're at 9. What is 9's policy? What is 9's job? And I want you to drill this in your brain because this is how we really understand recursion. This is how we really see that recursion expresses our decisions at each note. It's different for each note. Each note has a different state. Do you see how state differs? This is a recursion. Fundamental I want you to internalize. So we see 9. So what we need to do is we need to print 9. We see it has to print itself. And so 9 needs to visit its left. Nothing. 9 needs to visit its right. Nothing. So it has nothing left. We return to the 8. The 8 finished its right subtree. Nothing left. 8 has nothing to do left. And now we come back to 7. 7 was just visiting its right subtree. 7 says, OK, I'm finished. 7 is finished. And now we return to 10. And do you see how this all was the left subtree of 10? Do you see how our next task is to explore the right subtree of 10? So all the traversals do is they change how we traverse this tree. They change when we visit nodes. What we do is we check the right subtree and then what we need to do is we need to print 11 because 11 has that task to do. And so 11 has to visit its left. There's nothing here. So we come back to 11. And so 11 has to visit its right. And so 11 visits its right. And now 20 comes to itself. And 20 says, what do I need to do here? I need to print myself. Go left and right. So 20 will print itself. So 20 now needs to go left. So it comes to 14. 14 needs to print itself. And now 14 will go to the left. So 14 finds nothing. It'll go to the right as well. It'll find nothing. And now back to 20. What was 20 just doing? It was looking to its left. So what we're going to do is we're going to finish that. What is the next state in 20's stack ring? Well, we need to go to the right. We come to the right and we see 22. So we see 22 and 22's job. Well, it hasn't printed itself. It hasn't gone left. It hasn't gone right. It needs to do its job. So we're going to print 22. And then we'll go left. There's nothing. And then we'll go right. There's nothing. 22 is finished. It returns to 20. And then 20 has explored its right. It'll finish. 20 has nothing left to do. It'll return to 11. 11 has finished its right. So 11 has nothing to do. It's going to return to 10. 10 has finished its right. And 10 stack frame. The top level stack frame that drove us into the recursion is finished. We're going to return to our caller, whatever we return, whether it's the count of the nodes or something. And that is finished. That is the traversal of the tree. This is what their pre-order traversal looks like. The key is you don't really need to memorize these traversals. You literally can get the hint of what they are from the name. Anyway, I think you get the idea now. Let's go through the in-order and post-order and see how those work out. They're basically the same thing. So now what we're going to do is we're going to do an in-order traversal. And all that changes is we're going to do a different policy at each node. So let's define that policy. Okay, so now all we did was define a different policy. So we're going to go left. We're going to visit the node we're sitting at. And then we're going to go right. That is all that we're going to do different. So what we're going to do is we're going to start at the 10. The 10 will be called by an external caller and we're going to kick off our recursion. What we're going to do is we're going to execute a policy at 10. And when you really to internalize this, that recursion at each frame, every frame has a different state. Although every frame has the same policy, every frame will have a different state at different points in the recursion. So we're going to go left at 10. And then we come to 7. What does 7 need to do? 7 needs to go left. What will 6 do? 6 needs to go left. What will 1 do? 1 needs to go left. And 1 is going to go left. There's nothing there. It comes back. And so what does 1 need to do? 1 needs to print itself. So 1 printed itself. And after a printed self, it needs to go right. There's nothing there. And now what we need to do is come back. We come back to 6 because 1 is finished. We come back to 6. So 6 just finished up going left. So now 6 needs to print itself. So now 6 needs to go right. We see that there is nothing to 6 is right. So what we're going to do is we're going to just return to 7. We have nothing else to do at 6. So 7 just finished going left. So 7, it's next job in its stack frame is to print itself. So now 7 needs to go right. And now 8 needs to go left. We see in its stack frame, that's his first job. And then it goes left. It finds nothing. And then 8 needs to print itself. And then 8 needs to go right. And then 8 goes right. And then we see 9 needs to go left. There's nothing there. 9 needs to print itself. And then 9 needs to go right. There's nothing there. 9 has nothing to do. It returns to 8 and 8 has finished its right subtree. 8 has nothing to do left. So 8 returns to 7. 7 is finished. It's right subtree. So 7 returns to 10. 10 has finished. It's left subtree. All that work we were doing was on the left subtree. So now 10 needs to print itself. And now 10 needs to go to its right. And now 11 needs to go to its left. There's nothing to 11's left, it needs to come back to its self. And now 11 needs to visit itself. And then 11 goes to the right, 20, what does it need to do? It needs to go to the left, 14 needs to go to the left, there's nothing there, 14 needs to visit itself. And then we see 14 needs to go right, there's nothing there. So 14 returns to whoever called in which was 20, 20 is done going left. 20 needs to visit itself next. And then 20 needs to go to the right. And then we reach 22, 22 needs to go left to visit itself and go right. So it goes left, there's nothing, comes back. It needs to print itself. And now 22 needs to go right, there's nothing there. We return to 20, 20 is finished, 20 returns to its caller, its caller has finished its right subtree, 11 returns to its caller, 10, 10 has finished its right subtree. And we are finished printing it. And I want to notice there's something special about this, what we just did. There's something special right here because do you notice how these are in increasing order? This tree is a special kind of tree called a binary search tree. So the nature of the way these nodes are oriented is this node is in the middle of all of these guys and all of these guys. So if we go to the left, we go lesser in value, we go less than 10. Everything in the left subtree is less than 10, everything in the right subtree is greater than 10. So this is a special kind of tree, again, a binary search tree. You're probably already familiar with this if you are watching this. But anyway, so now I think you really get the idea, but just to drill it in, let's do the post order traversal. Okay, so now we're going to do the post order traversal and nothing changes, nothing changes except our policy at each node, the way we visit the nodes. So let's just go straight through this and you should be pretty rapid with this now. So what we're going to do is we're going to go to the left first. For 10, we'll go left first and then seven will go left. Six will go left. And this is starting to look like the in order traversal, but let's continue. So one go to the left. We go to the left and we see that we don't find anything. So we come back and this is the way this differs from our in order traversal. Instead of visiting ourselves next, the next task is to visit our right subtree. Remember, this is a post order traversal. We visit ourselves a post last, right? So what we're going to do is visit our right. There's nothing there and then we'll visit ourselves and what we're going to do is print ourselves. There's nothing left to do at one. So what we'll do is return to our caller six. So six needs to go to the right. There's nothing there. So we come back and so six needs to visit itself. So we print six. Six is finished. So six returns to its caller. We see its caller was seven. Seven just finished up its left subtree. So now seven goes to the right. Seven goes to the right and we come to eight. What does eight need to do? Eight needs to go to the left to the right and to itself. So we go left. There's nothing here. So we come back to eight. So eight now needs to explore its right. And so now eight is exploring its right. We come to the nine. So nine needs to explore its left. There's nothing there. So now nine needs to explore its right. There's nothing there. So now nine only needs to print itself. Nine returns to its caller. Eight. Eight realizes its finished its right subtree and now eight needs to print itself. Eight has nothing left to do. It returns to seven. Seven. All he needs to do is print itself. Seven has nothing left to do. It returns to its caller. Ten. Ten finished its left subtree. All it has to do is go right and now we come to eleven. Eleven needs to go to the left. Eleven does not have anything on its left. So eleven goes right. We come to twenty. Twenty needs to go left right and visit itself. We go to the left. We come to fourteen. We go to the left. There's nothing. We go to the right. There's nothing. We visit the node fourteen. That's the last task in our stack frame. We visit fourteen. We come back to twenty. Twenty has exhausted its left subtree. So twenty's next task is to go to the right. So now we're going to go to the right. We see twenty two. Twenty two's job is not to print itself. It's to go left to go right and then print itself. So now twenty two's going left. There's nothing there. It needs to go right. There's nothing there. It needs to print itself now. We come back to our caller twenty. It's finished exploring its right subtree. Now twenty needs to print itself. Twenty is finished with its tasks. So it comes back to eleven. Eleven realizes I'm done with my right subtree. Eleven needs to print itself now. And now eleven has nothing to do. We return to our caller and now we have ten. Ten realizes I'm done with my right subtree. And now finally ten prints itself. Ten realizes it has nothing left to do and we've completed our traversal. That is our post order traversal. That is basically how you do it. See the thing is you don't always have to do this recursively but what we're going to do is there's a certain way we need to visit these nodes. And however we structure our recursion, however we structure our stack, what items we push and what order is going to change how we visit these nodes. It's not that scary to deal with binary structures, binary tree structures because as long as we know our fundamentals, as long as we know how to visit nodes, we can be very flexible in how we deal with these structures. I haven't even gotten into breadth-restriversal. We can do a zigzag traversal. We would use a queue for that. But that's for another video. But I just want to introduce this concept. You're probably already familiar with this. If we are thinking about complexities, if we think about any of these traversals where we're touching all of the nodes, if N is the number of nodes, then the upper bound we can set on the time we're taking is going to be linear time. We're going to scale in a linear fashion as our tree gets bigger if we're touching all of the nodes. Anyway, we're going to get more familiar with tree complexities and all that. It gets fairly straightforward as you do more problems. But that is all for this video. If you like this video, hit the like button, subscribe to the channel. This was a very basic fundamental one. Of course, we have a table of content so you can skip through this. I would do not expect anyone to watch all of this. But that is all for this video and what I'm going to do. And um...",
        "description": "Lecture on Trees",
        "summary": "All it means simply is when we fill out the nodes, we go top to bottom, we go left to right.\nAnd do you see how we go from left to right?\nSo now that we understand our terminology very soundly, what we need to do is let's look at these traversals and yes, these are going to be the raw traversals you can do on a tree.\nOkay, so what we're going to do is we're going to do a traversal of this tree and there are three fundamental ways to traverse a binary tree.\nSo what I want you to see is in a pre-order traversal, in a pre-order traversal, we visit the node, we visit the left subtree, we visit the right subtree.\nDo you see how it's pre before the left and right?\nSo left subtree, visit the node and then visit the right subtree.\nWe go left subtree, we go right subtree, we visit the node.\nIt's after the left and right.\nSo the left and right stay in sequence, left and right stay in sequence, but the prefix tells us when we visit the node before the subtree.\nSo subtree will be left to right.\nSo do you see how I just put node left right?\nI see I have to do a node visit, I have to do a left subtree visit, I have to do a right subtree visit.\nSo what I'm going to do is I'm going to do the node visit.\nWe want to get our fundamentals down for visiting a node right now.\nWe're going to say I need to visit my left.\nSo this stack frame says I need to visit the left subtree.\nOkay, so now we recurse and now we just circled the left and now we're going to come down and we'll come to the 7.\nAnd notice the next step in 7's policy in this stack frame is to visit the left subtree.\nSo we visit the left subtree.\nSo do you see how recursion is we're executing the same policy at each node, but it's going to give us the behavior we desire because of the way we're ordering the visitations, right?\nSo what we're going to do is we'll visit the 6.\nWe're going to visit the 1.\nAnd then 1 says I need to visit my left subtree.\nWhat is left for this recursion in this stack frame to finish?\nAnd we see all that's left is visit the right subtree.\nLet's visit the right subtree.\nSo this says I need to visit my right.\nSo the 6 visits is right.\nIn 7's stack frame, in its policy, it's stack frame, it says I visited my left.\nAnd now all 7 has to do is visit its right subtree.\nAnd then it needs to go left.\nAnd so 9 needs to visit its left.\n9 needs to visit its right.\n7 was just visiting its right subtree.\nAnd so 11 has to visit its left.\nAnd so 11 has to visit its right.\nAnd so 11 visits its right.\nGo left and right.\nSo 20 now needs to go left.\nWell, we need to go to the right.\nSo we're going to go left.\nWe're going to visit the node we're sitting at.\nAnd then we're going to go right.\nSo we're going to go left at 10.\n7 needs to go left.\n6 needs to go left.\n1 needs to go left.\nAnd 1 is going to go left.\nSo 6 just finished up going left.\nSo now 6 needs to go right.\nWe see that there is nothing to 6 is right.\nSo 7 just finished going left.\nSo now 7 needs to go right.\nAnd now 8 needs to go left.\nAnd then 8 needs to go right.\nAnd then we see 9 needs to go left.\nAnd then 9 needs to go right.\nAnd now 10 needs to go to its right.\nAnd then we see 14 needs to go right, there's nothing there.\nSo 14 returns to whoever called in which was 20, 20 is done going left.\nAnd then 20 needs to go to the right.\nAnd then we reach 22, 22 needs to go left to visit itself and go right.\nAnd now 22 needs to go right, there's nothing there.\nEverything in the left subtree is less than 10, everything in the right subtree is greater than 10.\nOkay, so now we're going to do the post order traversal and nothing changes, nothing changes except our policy at each node, the way we visit the nodes.\nWe visit ourselves a post last, right?\nSo what we're going to do is visit our right.\nThere's nothing there and then we'll visit ourselves and what we're going to do is print ourselves.\nSo six needs to go to the right.\nEight needs to go to the left to the right and to itself.\nEight realizes its finished its right subtree and now eight needs to print itself.\nTwenty needs to go left right and visit itself.\nWe go to the right.\nSo now we're going to go to the right.\nIt's to go left to go right and then print itself.\nSo now twenty two's going left.\nIt needs to go right.\nSee the thing is you don't always have to do this recursively but what we're going to do is there's a certain way we need to visit these nodes.\nAnd however we structure our recursion, however we structure our stack, what items we push and what order is going to change how we visit these nodes.",
        "summaryStatus": "COMPLETED",
        "lastUpdated": 1741485498.070851
    }
}